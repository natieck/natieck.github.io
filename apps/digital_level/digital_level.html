<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Digital Level</title>
  </head>
  <body>
    <h1>Digital Level</h1>
    <button id="sensor_button" onclick="sensor_click(this);">start</button>
    &nbsp;&nbsp;<span id="counter"></span>
    <div><canvas id="level_canvas" width="400" height="400"></canvas></div>
    <p>Euler angles (absolute:<span id="angle_absolute"></span>)<br />
      alpha:<span id="alpha_angle"></span>,&nbsp;&nbsp;
      beta :<span id="beta_angle"></span>,&nbsp;&nbsp;
      gamma:<span id="gamma_angle"></span><br />
      angle:<span id="angle_from_horizontal"></span>
    </p>
    <p>Acceleration including Gravity<br />
      ax:<span id="acc_x"></span>,&nbsp;&nbsp;
      ay:<span id="acc_y"></span>,&nbsp;&nbsp;
      az:<span id="acc_z"></span>
    </p>
    <script>
      let ar, br, gr, ax, ay, az;
      let oriflg, rotflg, iosflg = 0, sensorflg = 0;
      let cnt = 0, ncnt = 10;
      const canvas = document.getElementById('level_canvas');
      let cx = canvas.width/2, cy = canvas.height/2;
      let ctx = canvas.getContext('2d');

      if(window.innerWidth < window.innerHeight)rotflg = 0;else rotflg = 1;
      window.addEventListener("orientationchange resize", function(){
        rotflg = 1-rotflg;
      }
			      
      function sensor_click(button){
        sensorflg = 1-sensorflg;
        if(sensorflg){
          button.innerHTML = "stop";
          if(DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
            // for iOS 13 or later
            // Get permission
            DeviceOrientationEvent.requestPermission().then(permissionState => {
              if (permissionState === 'granted') {
                // Add devicemotion to event listeners if permission is granted
                window.addEventListener("deviceorientation",ori_sensor,false);
              }else{
                // Processing if a permit is not granted
                alert('DeviceOrientationEvent is not permitted.');
              }
            }).catch(console.error) // Case that permission could not be obtained due to non-https communication, etc
          }else{
            // Browsers other than the above
            window.addEventListener("deviceorientation",ori_sensor,false);
          }
          if(DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function'){
            // for iOS 13 or later
            // Get permission
            DeviceMotionEvent.requestPermission().then(permissionState => {
              if (permissionState === 'granted') {
                // Add devicemotion to event listeners if permission is granted
                iosflg = 1;
                window.addEventListener("devicemotion",acc_sensor,false);
              }else{
                // Processing if a permit is not granted
                alert('DeviceMotionEvent is not permitted.');
              }
            }).catch(console.error) // Case that permission could not be obtained due to non-https communication, etc
          }else{
            // Browsers other than the above
            window.addEventListener("devicemotion",acc_sensor,false);
          }
        }else{
          button.innerHTML = "start";
          window.removeEventListener("deviceorientation",ori_sensor,false);
          window.removeEventListener("devicemotion",acc_sensor,false);
        }
      }
      
      function ori_sensor(ev){
        oriflg = ev.absolute;
        ar = ev.alpha || 0;
        br = ev.beta || 0;
        gr = ev.gamma || 0;
      }
      
      function acc_sensor(ev){
	document.getElementById('counter').innerHTML=cnt;
        if(++cnt > ncnt){
          cnt = 0;
          const acc=ev.accelerationIncludingGravity;
          if(iosflg){
            // Reverse the sign for iOS
            ax = -acc.x || 0;
            ay = -acc.y || 0;
            az = -acc.z || 0;
          }else{
            ax = acc.x || 0;
            ay = acc.y || 0;
            az = acc.z || 0;
          }
          document.getElementById('angle_absolute').innerHTML=oriflg;
          document.getElementById('alpha_angle').innerHTML=ar.toFixed(3);
          document.getElementById('beta_angle').innerHTML=br.toFixed(3);
          document.getElementById('gamma_angle').innerHTML=gr.toFixed(3);
          document.getElementById('acc_x').innerHTML=ax.toFixed(3);
          document.getElementById('acc_y').innerHTML=ay.toFixed(3);
          document.getElementById('acc_z').innerHTML=az.toFixed(3);
          let theta = Math.acos(az/Math.sqrt(ax*ax+ay*ay+az*az))*180/Math.PI;
          let theta_sign;
          if(Math.abs(br) < Math.abs(gr))theta_sign = -Math.sign(gr);
          else theta_sign = Math.sign(br);
          if(theta_sign!=0)theta*=theta_sign;
          document.getElementById('angle_from_horizontal').innerHTML=theta.toFixed(3);

          let w, x, y, x0, y0, x1, y1;
	  x= cx*(gr>90 ? gr-180 : -gr)/45;
	  y = -cy*br/45;
          if(x>cx){w=x/cx;x=cx;y*=w;}else if(x<-cx){w=-x/cx;x=-cx;y*=w;}
	  if(y>cy){w=y/cy;x*=w;y=cy;}else if(y<-cy){w=-y/cy;x*=w;y=-cy;}
          let grd = y/x;
	  if(grd < cy/cx){
	    x0 = 0;
	    x1 = canvas.width;
	    y0 = -cx*grd+cy;
	    y1 = cx*grd+cy;
	  }else{
	    x0 = -cy/grd+cx;
	    x1 = cy/grd+cx;
	    y0 = 0;
	    y1 = canvas.width;
	  }
	  x+=cx;
	  y+=cy;
	  if(rotflg){
	    w=x;x=y;y=w;
	    w=x0;x0=y0;y0=w;
	    w=x1;x1=y1;y1=w;
	  }
	  
          ctx.clearRect(0,0,canvas.width,canvas.height);

	  ctx.strokeStyle = 'blue';
	  ctx.beginPath();
	  ctx.moveTo(x0,y0);
	  ctx.lineTo(x1,y1);
	  ctx.stroke();

          ctx.strokeStyle = 'black';
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI*2);
	  ctx.stroke();
		
	  ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(0, 0, 5, 0, Math.PI*2);
	  ctx.fill();
        }
      }
    </script>
  </body>
</html>
